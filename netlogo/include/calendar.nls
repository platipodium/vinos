; SPDX-FileCopyrightText: 2022-2023 Helmholtz-Zentrum hereon GmbH (hereon)
; SPDX-License-Identifier: Apache-2.0
; SPDX-FileContributor: Carsten Lemmen <carsten.lemmen@hereon.de>

; Simple calendar implementation
; Reset the calendar to a default date
; @todo replace the functinoality with the time extension

to setup-calendar

  set days-in-months (list 31 28 31 30 31 30 31 31 30 31 30 31 )
  let _month-names (list "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec" )
  let _month-names-de (list "Jan" "Feb" "MÃ¤r" "Apr" "Mai" "Jun" "Jul" "Aug" "Sep" "Okt" "Nov" "Dez" )

  let _ymd substring date-and-time 16 length date-and-time
  let _month-name substring _ymd 3 6

  set year read-from-string substring _ymd (length _ymd - 4) length _ymd
  let _position  position _month-name _month-names
  if _position = -1 [
    let _position  position _month-name _month-names-de
  ]
  if _position = -1 [
    error "Cannot find the month name in the date string. This is likely a problem with localization: we currently support only English and German.  You can try to change your NetLogo Interface by switching to English in the Preferences menu."
  ]

  set month 1 + position _month-name _month-names
  set day read-from-string  substring _ymd 0 2

  set year year + int ((month + time-offset) / 12)
  ;print (sentence year  int ((month + time-offset) / 12) )
  set month (month + time-offset mod 12 )
  set month (month - 1) mod 12 + 1

  set day-of-year sum (sublist days-in-months 0 (month - 1)) + day
  if month > 2 [set day-of-year day-of-year + leap-year ]

end

; Advance the calendar by one day
to advance-calendar

  set day-of-year day-of-year + 1
  set day day + 1

  let critical-day item (month - 1) days-in-months
  ; February is longer in leap-years
  if month = 2 [
    set critical-day critical-day + leap-year
  ]

  ; if condition for number of days in months
  ; at end of month, we reset the days
  ; take care that lists are zero-based
  if day > critical-day [

    set day 1
    set month month + 1
  ]

  ; if condition for end of year
  ; at the end of a year, reset month and day and day of year
  ;if day-of-year > 365 + leap-year [
  if month > 12 [
    set year year + 1
    set month 1
    set day 1
    set day-of-year 1
  ]

end


to-report leap-year
  ; any year not divisible by 4 is not a leap year
  ; year mod 4 > 0 means there is a remainder on integer division
  ; at a report statement, the function is terminated and returns the value
  if ( year mod 4 > 0 )   [ report 0 ]
  if ( year mod 400 = 0 ) [ report 1 ]
  if ( year mod 100 = 0 ) [ report 0 ]
  report 1
end

to-report datetime
  report (word weekday-name " " year "-" month "-" day " (" day-of-year ")")
end

to-report datetime-short
  report (word (formatted-int year 4) (formatted-int month 2) (formatted-int day 2))
end

; Use Zeller's algorithm to calculate the weekday
; Return from 0 (Sunday) to 6 (Saturday)
to-report weekday
  let y0 int (year - (14 - month) / 12)
  let x int (y0 + y0 / 4 - y0 / 100 + y0 / 400)
  let m0 int (month + 12 * ((14 - month) / 12) - 2)
  let d0 (day + x + (31 * m0) / 12) mod 7
  report d0
end

to-report weekday-name
  let _weekday-names (list "Sun" "Mon" "Tue" "Wed" "Thu" "Fri" "Sat")
  report item weekday _weekday-names
end
