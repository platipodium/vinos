; SPDX-FileCopyrightText: 2022-2023 Universität Hamburg
; SPDX-FileCopyrightText: 2022-2023 Helmholtz-Zentrum hereon GmbH
; SPDX-FileCopyrightText: 2023 Hochschule Bremerhaven
; SPDX-License-Identifier: Apache-2.0
;
; SPDX-FileContributor: Carsten Lemmen <carsten.lemmen@hereon.de>
; SPDX-FileContributor: Sascha Hokamp <sascha.hokamp@uni-hamburg.de>
; SPDX-FileContributor: Jürgen Scheffran <juergen.scheffran@uni-hamburg.de>
; SPDX-FileContributor: Jieun Seo <jieun.seo@studium.uni-hamburg.de>
; SPDX-FileContributor: Serra Örey <soerey@hs-bremerhaven.de>

extensions [csv]

breed [boats boat]
breed [markers marker]
breed [logbooks logbook]

boats-own [
  ; Static properties individual to each boat
  boat-capacity           ; size of the boat, @todo should be in kg
  boat-steaming-speed     ; speed when steaming
  boat-landing-port       ; favorite-landing-port (in the current state there is the one favorite port, which is the landing port)
  boat-home-port          ; Home Port (in the current state only German home ports are considered
  boat-gears              ; list of available gears on this boat
  boat-type               ; Number 1-4 of the named cluster
  boat-length             ; length of boat in m, related (yet unknown) to capacity.
  boat-engine             ; power of the engine in kW

  boat-max-distance
  boat-max-duration  ; cluster-dependent typical trip length

  boat-trip-gear-catches       ; for each boat a vector of fish catches accumulated during a trip
  ;boat-history-prey-catches    ; for each boat a vector of total harvest of the fish species
  catch-efficiency-boat        ; how much fish is effectively catched

  revenue-boat             ; revenue for the fishing trip of the boat
  costs-boat               ; costs for the fishing trip of the boat
  boat-delta-gains          ; change in gain
  boat-gains                ; gain for the fishing trip of the boat
  boat-delta-priorities      ; change in priority
  boat-gear-priorities            ; priority for the pathway
  priority-weighted-average  ; priority weighted average of gain

  ; @todo make into a vector for the species
  solea-catch-kg          ; catch of solea in kg for a fishing trip
  solea-catch-euro        ; catch of solea in EUR 2015 for a fishing trip
  platessa-catch-kg       ; catch of platessa in kg for a fishing trip
  platessa-catch-euro     ; catch of platessa in EUR 2015 for a fishing trip
  crangon-catch-kg        ; catch of crangon in kg for a fishing trip
  crangon-catch-euro      ; catch of crangon in EUR 2015 for a fishing trip
  other-catch-kg          ; other catch in kg for a fishing trip
  other-catch-euro        ; other catch in EUR 2015 for a fishing trip

  boat-time-at-sea
  boat-time-at-sea-left
  boat-distance-at-sea

  ; value encoding the state the boat is in during a fishing trip.
  boat-trip-phase
  boat-trip-best-patch   ; location of patch with the highest catch during a trip
  boat-trip-best-catch   ; catch in kg of highest catch during a trip
  boat-needs-return?

  boat-hour ; Internal hour of the day to facility event-based scheduling
  boat-fishable-patches ; large memory required, is this problematic?
  boat-actions ; Agentset of actions for this boat

  boat-preys ; Agentset of preys for this boat
  boat-current-gear-index
  boat-current-prey-index

  ; Diagnostic facilties for
  ; Fuel intensity, i.e. Liters consumed per kg of catch l kg-1, should be 0.5-1
  ; LPUE  Landing Per Unit Effort as catch per seaday,  kg d-1, should be 300-900
  boat-total-time-at-sea  ; in hours
  boat-total-fuel         ; in l
  boat-total-landings     ; in kg

  ; A boat's logbook agent
  boat-logbook
]

logbooks-own [
  logbook-file-name
]


to setup-boats
  if any? actions [ask actions [die]]

  set-default-shape boats "boat top"
  if any? boats [
    ask boats [
      set boat-actions (turtle-set)
      die
    ]
  ]

  ; read distribution of boat properties
  let lpue-distribution csv-property "LPUE"
  let engine-distribution csv-property "VE_KW"
  let distance-distribution csv-property "distance_to_port"
  let triplength-distribution csv-property "triplength"
  let length-distribution csv-property "VE_LEN"
  let hours-distribution csv-property "total_fishinghours"

  ; @todo introduce quotas (=> Serra, asks Jonas)
  ask home-ports [
    (foreach (range 4) port-clusters [ [i j] ->
      hatch-boats j [
        create-link-with myself
        ; The 1-based boat types are
        ; 3: "typical" 1: "longer typical" 2: "flexible" 4: "not shrimper"
        set boat-type i
      ]
    ])

    ask link-neighbors [
      move-to [port-start-patch] of myself

      ; Create a boat with Gaussian distribution around mean with stdev
      set boat-length value-from-distribution butfirst butfirst item boat-type length-distribution

      ; The engine is relevant for plaice box (only for cluster 4).  It may also
      ; be relevant for estimating the steaming speed, as long as there is no
      ; independent data.
      set boat-engine value-from-distribution butfirst butfirst item boat-type engine-distribution
      set boat-steaming-speed 1.852 * ( 6 + random-float 7 )   ; range 6 to 12 kn, i.e. 11 to 20 km/h

      ; boat-max-distance and boat-max-duration are adaptable, but
      ; rather the fishers prefer boat-tripfrequency by budgeting
      ; against their boat-total-fishing-hours
      set boat-max-distance 2 * 0.001 * value-from-distribution butfirst butfirst item boat-type distance-distribution
      set boat-max-duration value-from-distribution butfirst butfirst item boat-type triplength-distribution

      ; create a list of gears, here we should @todo limit the gears available to a boat by the
      ; engine capacity.
      let _gear-ids sort [who] of gears
      set boat-gears map [ i -> gear i] _gear-ids
      set boat-gear-priorities n-values (length boat-gears)  [i -> random-float 1] ; initialize priority for the pathway

      let _crangon-gear-index position "Shrimp" gear-prey-names
      ifelse boat-type < 3 [
        ; shrimpers have only one gear
        set boat-gear-priorities  n-values number-of-gears [i  -> 0 ]
        set boat-gear-priorities replace-item _crangon-gear-index boat-gear-priorities  1
        set boat-current-gear-index  _crangon-gear-index
      ][
        ; non-shrimpers randomly choose between all other gears
        set boat-gear-priorities replace-item _crangon-gear-index boat-gear-priorities 0
        let _sum-priorities sum boat-gear-priorities
        set boat-gear-priorities n-values number-of-gears [ i -> item i boat-gear-priorities / _sum-priorities ]
        set boat-current-gear-index (index-max-one-of boat-gear-priorities)
      ]

      ;print (sentence boat-current-gear-index item boat-current-gear-index gear-names item  boat-current-gear-index gear-prey-names

      set boat-current-prey-index position (item boat-current-gear-index gear-prey-names)  prey-names

      ; Boat capacity is not relevant for shrimpers as freshness is key concern
      set  boat-capacity 100000                                  ; kg of storage

      set  boat-trip-gear-catches         n-values number-of-gears  [?1 -> 0 ]
      set  catch-efficiency-boat   n-values number-of-gears  [igear -> 1
        ;(item igear gear-catch-efficancy) + random-float 0.20 - random-float 0.40
      ]

      ;      set  catch-efficiency-boat   n-values number-of-gears  [?1 -> (0.15 + random-float 0.20)]
      set  revenue-boat            n-values number-of-gears  [?1 -> 0 ]   ; revenue for the fishing trip of the boat
      set  costs-boat              n-values number-of-gears  [?1 -> 0 ]    ; costs for the fishing trip of the boat
      set  boat-gains               n-values number-of-gears  [?1 -> 0 ]    ; gain for the fishing trip of the boat
      set  boat-delta-priorities   n-values number-of-gears  [?1 -> 0 ]    ; change of priority for the pathway
      set label ""                                             ; ????

      ; About 160 boats of the entire fleet don't change at all, make them have available only 1 gear
      ; there are smaller groups of boats that do different things.  Only for those allow to have multiple years available
      ; there are some seasonal changes, but likley not at monthly or sub-monthly scale. Let's try 3 months
      ; Also include every 3 months when gear change is deliberated the previous year's experience
      ; Add location and fishing trip length in option pathways.

      set boat-trip-phase 1 ; in port and available
      set boat-home-port myself
      set boat-needs-return? false
      set boat-hour 0
      set boat-fishable-patches boat-accessible-patches ;with [traffic-suitability > 0.9]
      set boat-actions (turtle-set)

      set boat-total-time-at-sea 0
      set boat-total-landings 0
      set boat-total-fuel 0
    ]
    ask my-links [set hidden? true]
  ]

  ; Create a log book
  ask one-of boats [
    let _logbook nobody
    hatch-logbooks 1 [
      set hidden? true
      set logbook-file-name (word "results/logbook_" [who] of myself ".txt")
      if file-exists? logbook-file-name [carefully [file-delete logbook-file-name][]]
      set _logbook self
    ]
    set boat-logbook _logbook
    write-log (word "Logbook of boat " who )
    write-log (word "Boat is a " round boat-length " m trawler with engine power "
        round boat-engine " kW")
    write-log(word "Steaming speed is " precision boat-steaming-speed 1 "km a-1")
    write-log (word "Equipped with gear " [gear-name] of (item boat-current-gear-index boat-gears)
        ", targets " item boat-current-prey-index prey-names)
  ]

end

to-report csv-property [x]

  ; Prefer actual data over fake data but fall back to it if the actual data
  ; (prefixed "musselabm") cannot be found
  let _filename (word "../data/orey_etal_data/musselabm-" x ".csv")
  let _data "####"
  carefully [
    set _data csv:from-file _filename
  ][
    set _filename (word "../data/orey_etal_data/fake_" x ".csv")
    set _data csv:from-file _filename
  ]
  ; Remove any comments starting with #
  while [starts-with _data "#" ] [ set _data butfirst _data]
  report butfirst _data
end

to-report __test_csv_property
  ;let lpue csv-property "LPUE"
  ;report lpue = [[1 41.33597392121994 44.29353998676394 12.592817787094033 11.456572055826198 96.83554521537783] [2 44.896109846997646 44.93153848086322 10.283125939897474 27.14061269693432 63.39053728677305] [3 52.3697708750142 54.51564668646204 15.098579547056138 27.91232373317848 111.57142350676918] [4 3.845738658502041 13.822901977235906 18.237950929313804 0.9253936126421393 60.43421042459698]]
  report true
end


; ---------------------------------------------------------------------------------
; The core of the boat movement are the boat trip phases from 0 (rest) to 5 (land)
; 0 in port not available, i.e. resting, refueling, grounded
; 1 in port and available
; 2 at sea and searching for place to start fishing
; 3 at sea and ready to fish
; 4 at sea, needing to go home
; 5  in port, need to unload

; Boat phase 0.  Boat procedure to rest.  This is dependent on weekends and for
; shrimpers also on Ramadan in Morocco, where 90% of landed shrimp is processed.
to boat-rest-port
  let _imonth time:get "month" date - 1

  ; Boats rest for at least 11 hours and regain their ability to stay offshore
  set boat-time-at-sea 0
  set boat-time-at-sea-left boat-max-duration
  write-log (word "Need to rest 11 hours")
  set boat-hour boat-hour + 11

  ; If on Monday, rest at least until 4 am
  let _day-of-week time:get "dayofweek" date
  if  _day-of-week = 1 and boat-hour < 4 [
    write-log (word "Need to wait until 4 am")
    set boat-hour 4
  ]

  ; Boats arriving in port on Saturday don't go out again, neither do boats go
  ; out on a Sunday or before Monday 4 am.  Shrimpers don't go out during Ramadan.
  ; On other days, just rest 11 hours.
  ifelse _day-of-week = 6 or holiday?
  or (boat-prey = "Crangon" and is-ramadan?) [
    set boat-hour 24
    write-log (word "Won't go out this " time:show date "EEEE" " at all")
  ][
    set boat-trip-phase 1 ; ready to leave port
  ]

  ; Introduce some weather, based on statistics of wind speeds exceeding
  ; a threshold.  See calendar.nls for details of the implementation
  if boat-trip-phase = 1 and storm? [
    set boat-hour 24
    set boat-trip-phase 0
    write-log (word "Won't go out for bad weather")
  ]

  ; Introduce gain expectation from data be Temming et al. MEPS
  ; This is highlgy variable (from 1.5 to 15), so choose with that
  ; probablity whether to go out or stay in port
  if (boat-trip-phase = 1  and item _imonth fleet-landing-climatology < random-float max fleet-landing-climatology) [
    set boat-hour 24
    write-log (word "Won't go out for expected bad catch")
    set boat-trip-phase 0
  ]
 end

; Boat trip phase 1. This is a boat procedure initializing a new
; fishing trip from the start patch of its associated
; favorite port.
to boat-leave-port

  ; Determine start end end patches of fishing activity.  This is usually the start/landing
  ; patch of a harbour, but for fishery subject to plaice box restriction, this is the nearest
  ; patch outside the plaice box.
  write-log (word "Leaves port " [port-name] of boat-home-port)
  let _patch [port-start-patch] of boat-home-port    ; starting patch of the boat
  face _patch
  let _gis-scale gis-scale
  let _distance gis-scale * distance _patch

  ; Do not show the movement during leaving port unless we're following one boat
  if not one? [pen-up]
  move-to _patch

  if not [accessible?] of patch-here [
    error (sentence "Boat" who "on inaccessible patch" patch-here "during phase" boat-trip-phase " (leaving port)")
    stop
  ]

  set boat-distance-at-sea boat-distance-at-sea + _distance
  set boat-time-at-sea  boat-time-at-sea + _distance / boat-steaming-speed
  set boat-time-at-sea-left boat-time-at-sea-left - _distance / boat-steaming-speed
  set boat-hour boat-hour + _distance / boat-steaming-speed

  write-log (word "Arrives at sea")

  set boat-trip-phase 2 ; available at start patch

end


; This is a boat procedure  where a boat lands at a port and offloads its cargo
; here the optimization is done and the memory update
to boat-land-port
  let _imonth time:get "month" date - 1
  let _fuel-cost boat-trip-fuel-cost
  let _wage-cost boat-trip-wage-cost

  if (sum boat-trip-gear-catches > 0 ) [
    set costs-boat n-values (number-of-gears) [ i -> _fuel-cost + _wage-cost ]
  ]

  ; Calculate the boat revenue depending on the landed species and the port, simple assumption is 3 EUR kg-1
  ; @todo: procedure which also considers the other species which are caugth
  set revenue-boat n-values (number-of-gears)[igear -> (item igear boat-trip-gear-catches  * (item boat-current-prey-index prey-prices))]

  set boat-gains n-values (number-of-gears ) [i -> item i revenue-boat - item i costs-boat]
  let sum-boat-gains sum boat-gains
  let sum-boat-priorities-gains sum n-values (number-of-gears) [i -> item i boat-gear-priorities * item i boat-gains]

  carefully [
    set boat-delta-priorities n-values (number-of-gears) [
      i -> adaptation * (item i boat-gear-priorities) * (( item i boat-gains) - sum-boat-priorities-gains) / sum-boat-gains
    ]
  ][]

  set boat-gear-priorities n-values (number-of-gears) [i -> item i boat-gear-priorities + item i boat-delta-priorities]

  ; A typical revenue should be around 7500 € considering the relative relation to transport/operating costs.
  ; At the moment, boat-tranpsortation cost are 70 k€, op-costs are 2000 € revenue is 0.0002
  ;if one? [print (sentence "R:" boat-transportation-costs boat-operating-costs revenue-boat [action-catch] of boat-actions)]
  if one? [print (word "R: " round item boat-current-gear-index boat-trip-gear-catches " kg-"
    item boat-current-prey-index prey-names "-"
    [gear-name] of item boat-current-gear-index boat-gears " "
    round item boat-current-gear-index revenue-boat  "€ - "
    round _fuel-cost "€ - " round _wage-cost "€ = "
    round item boat-current-gear-index boat-gains "€"
    ;[action-catch] of boat-actions
    )
  ]

  ; Add diagnostics of the actually caught species to fleet monthly diagnostics
  ; @todo later expand to other species
  let _boat-gain item boat-current-gear-index boat-gains
  let _boat-catch item boat-current-gear-index boat-trip-gear-catches
  let _boat-revenue _boat-catch * (item boat-current-prey-index prey-prices)
  if ([gear-name] of (item boat-current-gear-index boat-gears) = "TBB20CSH") [
    set  fleet-monthly-landing replace-item _imonth fleet-monthly-landing (item _imonth fleet-monthly-landing + _boat-catch)
    set  fleet-monthly-revenue replace-item _imonth fleet-monthly-revenue (item _imonth fleet-monthly-revenue + _boat-revenue)
    set  fleet-monthly-effort-hours replace-item _imonth fleet-monthly-effort-hours (item _imonth fleet-monthly-effort-hours + boat-time-at-sea)
    set  fleet-monthly-effort-mwatthours replace-item _imonth fleet-monthly-effort-mwatthours (item _imonth fleet-monthly-effort-mwatthours + boat-time-at-sea * boat-engine / 1000)
    set  fleet-monthly-hours replace-item _imonth fleet-monthly-hours (item _imonth fleet-monthly-hours + boat-time-at-sea)
    set  fleet-monthly-fuel replace-item _imonth fleet-monthly-fuel (item _imonth fleet-monthly-fuel + boat-time-at-sea * boat-fuel-lperh)
  ]

  write-log (word "Landed  " round _boat-catch " kg " item boat-current-prey-index prey-names)
  write-log (word "Sold fish for "round  _boat-revenue " €" )
  write-log (word "Consumed " round (boat-fuel-lperh * boat-time-at-sea)  " l diesel at " oil-price " ct l-1,  costing " round _fuel-cost " €")
  write-log (word "Paid " round _wage-cost  " € for wages")
  write-log (word "Made net gain " round _boat-gain " €")

  set boat-total-fuel boat-total-fuel +  boat-fuel-lperh * boat-time-at-sea
  set boat-total-landings boat-total-landings +  item boat-current-gear-index boat-trip-gear-catches

  ; Boat time is in hours, add the trip's hours to the total boat sea days and
  ; reset the trip data.  Sea days are converted from sea hours by convention
  set boat-total-time-at-sea boat-total-time-at-sea + boat-time-at-sea
  set boat-time-at-sea  0
  set boat-time-at-sea-left 0

  set boat-trip-gear-catches map [i -> 0] boat-trip-gear-catches
  set boat-distance-at-sea 0
  set boat-trip-phase 0

  ; now update the memory from this trip's best catch and only if
  ; this location is not a preferred one for more than 10 other boats
  let _min-action-distance 5 ; minimum patch distance between two actions
  let _my-action nobody
  if boat-trip-best-catch > 0 and count actions-on boat-trip-best-patch < 11 [

    let _catch boat-trip-best-catch
    let _patch boat-trip-best-patch
    let _prey-price item boat-current-prey-index prey-prices
    let _boat-cost-per-km (boat-fuel-lperh * oil-price / 100  + wage) / boat-steaming-speed

    ; @todo make sure that actions have a minimum distance from one another...
    ifelse count boat-actions < memory-size [

      ifelse any? boat-actions with [distance _patch < _min-action-distance][
        ; don't do anything
      ][
        hatch-actions 1 [
          set _my-action self
          ; @todo fix gear selection (has no impact yet)
          set action-gear [item 0 boat-gears] of myself
          set action-catch _catch
          set action-age 0
          move-to _patch
        ]
        write-log (word "Remember this fishing location " _patch " with catch " _catch "kg")
      ]

      set boat-actions  (turtle-set _my-action boat-actions)
    ][

      ask boat-actions [
        ; @todo improve heading-dependent gis-scale calculation
        let _action-distance  gis-scale * distance myself
        set action-gain action-catch * _prey-price - _action-distance * _boat-cost-per-km
      ]

      ; Check whether the boat already remembers this patch and
      ; update its catch accordingly, otherwise choose one with
      ; lower previous catch
      let _nearby-actions boat-actions with [distance _patch < _min-action-distance]
      ifelse any? _nearby-actions [
        set _my-action min-one-of _nearby-actions [action-gain]
        write-log (word "Choose to try at nearby remembered location")
      ][
        set _my-action min-one-of boat-actions [action-gain]
        write-log (word "Choose to try at other remembered location")
      ]
      if _my-action != nobody [
        ; replace properties of that action
        ask _my-action [
          set action-gear [item 0 boat-gears] of myself ; @todo update index
          set action-catch [boat-trip-best-catch] of myself
          set action-age 0
          move-to [boat-trip-best-patch] of myself
        ]
        write-log (word "Udate remember this fishing location " boat-trip-best-patch " with catch " boat-trip-best-catch " kg")
      ]
    ]
  ]
  set boat-trip-best-catch 0
  set boat-trip-best-patch nobody

  ; @todo find out how long it takes to land the catch and clean the boat, here, we assume 2 hours
  set boat-hour boat-hour + 2
  write-log (word "Unloading for 2 hours finished")
end

; This is a boat procedure  where a boat
; steams from it's start patch to a preferred location for fishing
to boat-choose-start

  let _patch nobody
  let _patches nobody
  let _boat-cost-per-km (boat-fuel-lperh * oil-price / 100  + wage) / boat-steaming-speed
  let _prey-price item boat-current-prey-index prey-prices
  let _fishable-patches boat-fishable-patches

  ifelse count boat-actions < memory-size  or memory-size < 1 [
    ; random patch if not sufficient memory accumulated yet (learning phase)

    ifelse patch-here = [port-start-patch] of boat-home-port  [
      set _patches n-of 10 boat-fishable-patches in-radius boat-max-distance ; with [ count boats-here = 0 and distance myself < boat-max-distance]
      set _patch max-one-of _patches [traffic-suitability]
      if one? [ print (sentence "Boat" who "leaves from home and searches in radius"  boat-max-distance)]
      write-log (word "Searched for new fishing opportunities in distance " boat-max-distance " km")
    ][
      set _patches n-of 10 boat-fishable-patches in-radius (boat-max-distance / 2)
      set _patch max-one-of _patches [traffic-suitability]
      if one? [ print (sentence "Boat" who "leaves from " patch-here "and searches in radius"  (boat-max-distance / 2))]
      write-log (word "Searched for new fishing opportunities in distance " (boat-max-distance / 2) " km")
    ]

  ][
    ask boat-actions [
      ; @todo improve heading-dependent gis-scale calculation
      let _action-distance  gis-scale * distance myself
      set action-gain action-catch * _prey-price - _action-distance * _boat-cost-per-km
    ]

    let _mean-gain median [action-gain] of boat-actions

    ; How do we choose our next action, this could be a random action better than
    ; average, or it could be simply the best action at hand.
    let _action one-of boat-actions with [ action-gain > _mean-gain ]
    ;let _action max-one-of boat-actions [action-gain]

    if _action != nobody [
      set _patch [ patch-here ] of _action
      if one? [ print (sentence "Boat" who "leaves from " patch-here "to memorized " _patch "with expected gain" [action-gain] of _action)]
      write-log (word "Remembered fishing location at " _patch " with expected gain " [action-gain] of _action " €")
    ]

    ; Introduce some random component
    set _patches (patch-set _patch [neighbors] of _patch) with [member? self _fishable-patches ]
    ;set _patches boat-fishable-patches with [ count other boats-here = 0 and distance _patch < 6 ]
    if _patches != nobody [
      if count _patches > 10 [ set _patches n-of 10 _patches ]
      let _nearby-patch max-one-of _patches [traffic-suitability]
      if _nearby-patch != nobody [
        set _patch _nearby-patch
        if one? [ print (sentence "Boat" who "corrects position to " _patch )]
        write-log (word "Corrected position to " _patch)
      ]
    ]
  ]

  ; If there are not accessible patches found, go home and try again
  ifelse (_patch = nobody or [not accessible?] of _patch) [
    set boat-trip-phase 4 ; need to go home
    write-log (word "Couldn't find good fishing location, returning home")
  ][
    face _patch
    let _distance gis-scale * distance _patch

    ; Do not show the movement during choosing start unless we're following one boat
    if not one? [pen-up]
    move-to _patch
    if not [accessible?] of patch-here [
      error (sentence "Boat" who "on inaccessible patch" patch-here "during phase" boat-trip-phase "(choose start)")
    ]

    set boat-distance-at-sea boat-distance-at-sea + _distance
    set boat-time-at-sea  boat-time-at-sea + _distance / boat-steaming-speed
    set boat-time-at-sea-left boat-time-at-sea-left - _distance / boat-steaming-speed
    set boat-hour boat-hour + _distance / boat-steaming-speed
    write-log (word "Found suitable location, ready to deploy gear")

    set boat-trip-phase 3 ; ready to fish
    set heading random 360
  ]
end

; This is a boat procedure that occurs in two steps.  First, go to the
; port start patch of a home port, then go to the port itself.
to boat-return-port

  let _patch [port-start-patch] of boat-home-port
  face _patch
  let _distance gis-scale * distance _patch
  let _time _distance / boat-steaming-speed

  ; don't show returning to port
  pen-up
  move-to _patch
  write-log (word "Arrived at port entry location")

  set boat-distance-at-sea boat-distance-at-sea + _distance
  set boat-time-at-sea boat-time-at-sea  + _time
  set boat-time-at-sea-left boat-time-at-sea-left - _time
  set boat-hour boat-hour + _time

  face boat-home-port
  set _distance gis-scale * distance boat-home-port
  set _time _distance / boat-steaming-speed

  move-to boat-home-port
  write-log (word "Arrived in  port " [port-name] of boat-home-port)

  set boat-distance-at-sea boat-distance-at-sea + _distance
  set boat-time-at-sea boat-time-at-sea  + _time
  set boat-time-at-sea-left boat-time-at-sea-left - _time
  set boat-hour boat-hour + _time

  set boat-trip-phase 5 ; need to land

end


; This is a boat procedure  where a boat
; fishes in a straight line
to boat-make-haul
  let _gear item boat-current-gear-index boat-gears
  let _prey [gear-species] of _gear
  let _cluster boat-type
  let _power boat-engine

  let _imonth time:get "month" date - 1
  let _gear-index boat-current-gear-index ; needed to make accessible to patches
  let _patch-prey-index position _prey patch-prey-names

  ; A boat deploys the gear with the highest priority
  let _haul-width [gear-width] of _gear

  ; @todo should we adjust the gear-speed with the boat-engine?
  let _boat-fishing-speed [gear-speed] of _gear

  ; Set some parameters for numerical integration
  let _haul-time 1 ; one hour @todo maybe set differnet haul-time depending on gear? (crangon could be 1.5h?)
  let _sub-steps  10 ; partition the _haul-time in _sub-steps for actual fishing
  let _step-time _haul-time * 1.0 / _sub-steps

  ; Calculate conversion factor netlogo units to km, needs to be recalculated after
  ; every change of heading
  let _gis-scale gis-scale
  let _patch nobody
  let _haul-distance 0
  if _gis-scale > 0 [
    set _haul-distance  (_boat-fishing-speed * _haul-time / _gis-scale)
    set _patch patch-ahead _haul-distance
  ]
  ; find (up to ten times) a straight line path with accessible patches by turning,
  ; first slow then more
  ; @todo also make sure no other boats in path
  let _counter 1
  while [ _gis-scale <= 0 and (_counter < 10) and (_patch != nobody) and (not boat-accessible-path _haul-distance _sub-steps) ] [
    set heading heading - 180 - _counter * 5 + random (_counter * 10 + 1)
    set _gis-scale gis-scale
    set _haul-distance  (_boat-fishing-speed * _haul-time / _gis-scale)
    set _counter _counter + 1
    set _patch patch-ahead _haul-distance
  ]
  if _counter >= 10 [set _patch nobody]

  ; Partition the fishing in small intervals, this could probably be optimized by calculating the
  ; intersection with the patch boundaries
  ifelse _patch != nobody [

    write-log (word "Found suitable straight-line fishing path in direction " heading "°N")

    let _new-catches n-values length boat-gears [i -> 0]
    let _haul-catches n-values length boat-gears [i -> 0]
    ; @todo the following call gives a wrong value
    ; let _step-distance (fishing-speed * _step-time / _gis-scale)
    ; print (sentence _step-distance "=" _boat-fishing-speed "*" _step-time "/" _gis-scale)

    let _step-distance _haul-distance / _sub-steps
    if show-boats? [pen-down]

    repeat (_sub-steps) [
      ; trawl here
      set _new-catches boat-catch-species (_step-time * _boat-fishing-speed)

      ; update diagnostics and stocks of trawled patch
      ask patch-here [
        ; Fishing effort is measured as Megawatt hours
        set patch-monthly-effort-hours replace-item _imonth patch-monthly-effort-hours (
          item _imonth patch-monthly-effort-hours + _step-time
        )

        set patch-monthly-effort-mwatthours replace-item _imonth patch-monthly-effort-mwatthours (
          item _imonth patch-monthly-effort-mwatthours + _step-time * _power / 1000.0
        )

        set patch-monthly-swept-area replace-item _imonth patch-monthly-swept-area (
          item _imonth patch-monthly-swept-area + _haul-width * _step-time * _boat-fishing-speed
        )

        if _patch-prey-index > -1 [
          set  patch-prey-biomasses replace-item _patch-prey-index patch-prey-biomasses  (
            ((item _patch-prey-index  patch-prey-biomasses ) * area - (item _gear-index _new-catches) )/ area
        )]
      ]

      ;if (not member? (patch-ahead _step-distance) boat-fishable-patches ) [
      ;  error (sentence "Boat" who "on inaccessible patch" patch-here "during phase" boat-trip-phase "(haul)")
      ;]
      forward _step-distance

      set _haul-catches n-values (number-of-gears) [i -> (item i _haul-catches + item i _new-catches)]

      write-log (word "Trawl filling with another " (precision item boat-current-gear-index _new-catches 1)" kg" )

      if item boat-current-gear-index _new-catches > boat-trip-best-catch [
        set boat-trip-best-catch item boat-current-gear-index _new-catches
        set boat-trip-best-patch patch-here
        write-log (word "Noting particularly good location " boat-trip-best-patch " catching " round boat-trip-best-catch " kg")
      ]
    ] ; end of repeat _sub-steps

    write-log (word "Hauled " (round item boat-current-gear-index _haul-catches) " kg abord")

    let _next-heading heading - 180 - 10 + random (21 + 1)

    set boat-time-at-sea boat-time-at-sea  + _haul-time
    set boat-distance-at-sea boat-distance-at-sea + _haul-distance
    set boat-time-at-sea-left boat-time-at-sea-left - _haul-time
    set boat-hour boat-hour + _haul-time

    let distance-left boat-steaming-speed * boat-time-at-sea-left ; at typical speed of 19 km / h this is 1368 km
    face  [port-start-patch] of boat-home-port

    if distance-left < 1.1 * gis-scale * distance [port-start-patch] of boat-home-port [
      set boat-trip-phase 4
    ]

    set heading _next-heading

    ; If the catch is not worth keeping, discard it entirely. Fishers do not want to keep
    ; the bad haul, as this  would restrict their left time, but only there are > 24 hours left
    ; On the other hand, on good haul make sure to return within 24 hours to keep it fresh
    if (boat-time-at-sea-left > 24) [
      ifelse item boat-current-gear-index _haul-catches < min-fresh-catch [
        set _haul-catches n-values length boat-gears [i -> 0]
        set boat-trip-phase 2
        write-log (word "Discarded catch " (round item boat-current-gear-index _haul-catches) " as insufficient")
      ][
        set boat-time-at-sea-left 24
        write-log (word "Need to return within next 24 hours to keep catch fresh")
      ]
    ]
    set boat-trip-gear-catches n-values (number-of-gears) [i -> (item i boat-trip-gear-catches + item i _haul-catches)]

    ; If the boat is full, also need to return
    if item boat-current-gear-index boat-trip-gear-catches > boat-capacity [
       write-log (word "Boat reached capacity " boat-capacity ", returning to port")
      set boat-trip-phase 4
    ]
  ][
    ; Could not find a straight-line haul from hear, so continue steaming
    set boat-trip-phase 2
    write-log (word "Could not find strait-line haul, continue to steam")
  ]

  ; After a haul, create the action properties
  ; -> patch location of the haul
  ; -> gain during this haul
  ; -> gear used during this haul

  ; After the action is created
  ; -> add to patthways if length pathways < memory-size
  ; -> or, replace lowest-ranking (in terms of gain) item in pathways list

end


; This boat procedure return the agent-set of accessible patches considering
; the plaice box restriction if highest priority gear's prey is plaice.
to-report boat-accessible-patches

  let _patches patches with [accessible?]

  ; identify patches influenced by tides
  let _tidal-patches _patches with [depth <= 4 and distance-to-coast < 5 ]

  ask _patches [set temporary depth]

  ; Assume a 12:25 h lunar tide with 2 m amplitude in all Wadden patches
  ask _tidal-patches [
    set temporary depth + 2 * sin ( 2 * pi * (time:get "hours" date + 24 * time:get "dayofyear" date + 365.25 * time:get "year" date) / 12.42)
  ]

  ;set _patches patches with [accessible? and temporary > 2]

  let _prey item boat-current-prey-index prey-names
  if (boat-engine > 221 and _prey = "Plaice") [
    set _patches _patches with [not plaice-box?]
  ]

  report _patches

end

to-report boat-catch-species [haul-length]
  ; calculate the values for each patch and every target species
  ;(sole, plaice and shrimp), i.e. biomass cath in KG
  ; @todo: negative values possible for patch-prey-biomasses

  let ispecieslist n-values (number-of-gears) [igear -> position ([gear-species] of item igear boat-gears) patch-prey-names ]

  report n-values (number-of-gears) [ igear ->
     (item igear catch-efficiency-boat) * (item (item igear ispecieslist) patch-prey-biomasses)
      * (([gear-width] of item igear boat-gears) * haul-length) * (boolean2int (item (item igear ispecieslist) patch-prey-biomasses > 0) )
      * [traffic-suitability] of patch-here
  ]
end

; Report true if all patches touched within distance d at substeps n
; are accessible. This is a boat procedure.
to-report boat-accessible-path [_distance _n]
  if breed != boats [ error "This procedure only applies to boats"]

  ;let _patches-ahead (patch-set)
  let _fishable-patches boat-fishable-patches

  foreach range _n [ _i ->
    ;let _patch-ahead patch-ahead ((_i + 1) * _distance / _n)
    ;set _patches-ahead (patch-set _patches-ahead _patch-ahead)
    ;  if not member? _patch-ahead _fishable-patches [report false]
    if not member? (patch-ahead ((_i + 1) * _distance / _n)) _fishable-patches [report false]
  ]

  report true
end

; turtle procedure, returns the scaling km/netlogo-unit in the heading of
; a turtle
to-report gis-scale

  hatch-markers 1 [
    create-link-with myself
  ]
  let _marker one-of link-neighbors with [breed = markers]

  ; If we're at the edge, we need to move away one step (and later
  ; revisit this place
  let _xy (list xcor ycor)
  setxy max (list xcor (min-pxcor + 2)) max (list ycor (min-pycor + 2))
  setxy min (list xcor (max-pxcor - 2)) min (list ycor (max-pycor - 2))

  ask _marker [forward 1]
  let _gis-distance gis-envelope-distance (turtle-set self  _marker)

  if _gis-distance < 0.0001 [
    print (sentence _xy )
  ]

  ; Cleanup
  setxy item 0 _xy item 1 _xy
  ask my-out-links with [breed = markers][die]
  ask _marker [die]

  report  _gis-distance
end

; Boat procedure reporting the active gear, i.e. that with the highest
; priority
to-report boat-gear
  report [gear-name] of item boat-current-gear-index boat-gears
end

; Boat procedure reporting the active prey, i.e. that caught with the highest
; priority gear
to-report boat-prey
  report [gear-species] of item boat-current-gear-index boat-gears
end

; Boat procedure returning fuel consumption in l h-1
to-report boat-fuel-lperh
  ; "Eins bleibt immer gleich: Pro Stunde rechnet man pro PS mit einem Konsum von 0,21 Liter bei einem
  ; Diesel und 0,29 Liter bei Benzin als Treibstoff.” https://www.boatsandstories.com/verbrauch_1-3-2/
  ; The conversion from PS to kW is 1.35962, i.e. a typical boat uses 0,2855202 l kW-1 h-1
  ; A 200 kW shrimper thus consumes 57 l h-1, or about 30 € h-1, regardless of steaming or fishing.
  ; In the end transportation costs should be 15% of crangon revenue, up to 30% for platessa/sole
  report boat-engine *  1.35962 * 0.21 ; is typically 60 l h-1
end

; Boat procedure returning fuel consumption in €
to-report boat-trip-fuel-cost
  report boat-fuel-lperh * oil-price / 100 * boat-time-at-sea ; typically 750 €
end

; Boat procedure returning wage cost in €
to-report boat-trip-wage-cost
  ; Typically there are 3 people aboard, i.e. 150 * 3 work hours per month.  Average wage is 5000+2*2000 per
  ; gross salary per month, adding 40% costs gives 12600 EUR, i.e. 84 € h-1, there is slider wage to
  ; adjust this
  ; in the end operating costs should be around 50% of revenue.
  report wage * boat-time-at-sea
end

to write-timestamp-log [_timestamp _entry ]
  if is-logbook? (boat-logbook) [ask boat-logbook [
    file-open logbook-file-name
    file-print (word _timestamp " " _entry)
    file-close
  ]]
end

to write-log [_entry ]
  if is-logbook? (boat-logbook) [
    let _timestamp (word time:show date "YYYY-MM-dd " int boat-hour ":" round ((boat-hour mod 1) * 5 / 3))
    let _envelope gis:envelope-of self
    write-timestamp-log (word _timestamp " " (precision item 0 _envelope 2) "°E " (precision item 2 _envelope 2) "°N")_entry
  ]
end

to boat-reset-diagnostics
  ask boat-actions [die]
  set boat-actions (turtle-set)

  set boat-total-time-at-sea 0
  set boat-total-landings 0
  set boat-total-fuel 0
end
