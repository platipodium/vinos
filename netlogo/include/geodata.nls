; SPDX-FileCopyrightText: 2022-2023 Universit√§t Hamburg
; SPDX-FileCopyrightText: 2022-2023 Helmholtz-Zentrum hereon GmbH
; SPDX-License-Identifier: Apache-2.0
; SPDX-FileContributor: Sascha Hokamp <sascha.hokamp@uni-hamburg.de>
; SPDX-FileContributor: Carsten Lemmen <carsten.lemmen@hereon.de>

to setup-maps

  no-display
  let _patches nobody

  gis:load-coordinate-system "../data/wgs1984.prj"
  let bathymetry-dataset gis:load-dataset "../data/gebco/gebco_2021_n56.0_s53.0_w2.0_e10.0.asc"

  ;new crangon dataset (no summer and winter change anymore but year around data)
  ;for the solea and platessa only the biomass of fish > minimum conservation reference sizes (MCRS) is introduced
  let crangon-summer-dataset gis:load-dataset "../data/thuenen/dis.crangon.min.max.asc"
  let crangon-winter-dataset gis:load-dataset "../data/thuenen/dis.crangon.min.max.asc"
  let platessa-summer-dataset gis:load-dataset "../data/thuenen/dis.pleuronectes.platessa.27.max.asc"
  let platessa-winter-dataset gis:load-dataset "../data/thuenen/dis.pleuronectes.platessa.27.max.asc"
  let solea-summer-dataset gis:load-dataset "../data/thuenen/dis.solea.24.max.asc"
  let solea-winter-dataset gis:load-dataset "../data/thuenen/dis.solea.24.max.asc"

  ; Set the world envelope to the union of all of our dataset's envelopes
  gis:set-world-envelope (gis:envelope-union-of (gis:envelope-of bathymetry-dataset)
;                                                (gis:envelope-of crangon-summer-dataset)
;                                               (gis:envelope-of crangon-winter-dataset)
;                                                (gis:envelope-of platessa-summer-dataset)
;                                                (gis:envelope-of platessa-winter-dataset)
;                                                (gis:envelope-of solea-summer-dataset)
;                                                (gis:envelope-of solea-winter-dataset)
  )

  ;gis:set-world-envelope (list 6.7 8.0 53.2 56.5)

  gis:apply-raster bathymetry-dataset depth

  ; The following removes NaN values which are not allowed
  ask patches with [not (depth <= 0 or depth > -1) ] [ set depth 9999 ]

  ; Convert from bathymetry to depth
  ask patches [ set depth ( - depth)]

  gis:apply-raster crangon-summer-dataset crangon-summer
  ask patches with [not (crangon-summer < 0 or crangon-summer > -1) ] [ set crangon-summer -9999 ]

  ; Creep-fill with nearest neighbor
  set _patches patches with [crangon-summer < 0 and depth > 0]
  repeat max-pxcor * 2 [
    ask _patches [
      let _neighbors neighbors with [crangon-summer >= 0]
      if any? _neighbors [
        set crangon-summer  mean [crangon-summer] of _neighbors
      ]
    ]
    set _patches patches with [crangon-summer < 0 and depth > 0]
  ]


  gis:apply-raster crangon-winter-dataset crangon-winter
  ask patches with [not (crangon-winter < 0 or crangon-winter > -1) ] [ set crangon-winter -9999 ]


  ; Creep-fill with nearest neighbor
  set _patches patches with [crangon-winter < 0 and depth > 0]
  repeat max-pxcor * 2 [
    ask _patches [
      let _neighbors neighbors with [crangon-winter >= 0]
      if any? _neighbors [
        set crangon-winter  mean [crangon-winter] of _neighbors
      ]
    ]
    set _patches patches with [crangon-winter < 0 and depth > 0]
  ]


  gis:apply-raster solea-summer-dataset solea-summer
  ask patches with [not (solea-summer < 0 or solea-summer > -1) ] [ set solea-summer -9999 ]
  set _patches patches with [solea-summer < 0 and depth > 0]
  repeat max-pxcor * 2 [
    ask _patches [
      let _neighbors neighbors with [solea-summer >= 0]
      if any? _neighbors [
        set solea-summer  mean [solea-summer] of _neighbors
      ]
    ]
    set _patches patches with [solea-summer < 0 and depth > 0]
  ]

  gis:apply-raster solea-winter-dataset solea-winter
  ask patches with [not (solea-winter < 0 or solea-winter > -1) ] [ set solea-winter -9999 ]
  set _patches patches with [solea-winter < 0 and depth > 0]
  repeat max-pxcor * 2 [
    ask _patches [
      let _neighbors neighbors with [solea-winter >= 0]
      if any? _neighbors [
        set solea-winter  mean [solea-winter] of _neighbors
      ]
    ]
    set _patches patches with [solea-winter < 0 and depth > 0]
  ]

  gis:apply-raster platessa-summer-dataset platessa-summer
  ask patches with [not (platessa-summer < 0 or platessa-summer > -1) ] [ set platessa-summer -9999 ]
  set _patches patches with [platessa-summer < 0 and depth > 0]
  repeat max-pxcor * 2 [
    ask _patches [
      let _neighbors neighbors with [platessa-summer >= 0]
      if any? _neighbors [
        set platessa-summer  mean [platessa-summer] of _neighbors
      ]
    ]
    set _patches patches with [platessa-summer < 0 and depth > 0]
  ]

  gis:apply-raster platessa-winter-dataset platessa-winter
  ask patches with [not (platessa-winter < 0 or platessa-winter > -1) ] [ set platessa-winter -9999 ]
  set _patches patches with [platessa-winter < 0 and depth > 0]
  repeat max-pxcor * 2 [
    ask _patches [
      let _neighbors neighbors with [platessa-winter >= 0]
      if any? _neighbors [
        set platessa-winter  mean [platessa-winter] of _neighbors
      ]
    ]
    set _patches patches with [platessa-winter < 0 and depth > 0]
  ]

  ask patches [
    set area gis-patch-area
  ]

  update-owf

  calculate-distance-to-coast
  ; calculate-distance-to-port  ; needs ports defined, so do it later
end

to update-owf

  set owf-dataset load-dataset "OWF"

  let _owf-properties gis:property-names owf-dataset
  let _owf-list (list)
  let _year time:get  "year" date

  ; Use the existing "SHAPE_AREA" property to manipulate and filter data,
  ; by default set all to zero
  foreach gis:feature-list-of owf-dataset [ f ->
    gis:set-property-value f "SHAPE_AREA" 0
  ]

  ifelse  (_year > 2025) [
    set _owf-list (sentence
      gis:find-features owf-dataset "STATUS" "Production"
      gis:find-features owf-dataset "STATUS" "Construction"
      gis:find-features owf-dataset "STATUS" "Planned"
    )
  ][
    set _owf-list (sentence
      gis:find-features owf-dataset "STATUS" "Production"
      gis:find-features owf-dataset "STATUS" "Construction"
    )
    set _owf-list filter [ f -> gis:property-value f "year" <= year ] _owf-list

  ]

  ; Use the filtered list to set the shape area property and that area
  ; to calculate frational coverage
  foreach _owf-list [ f ->  gis:set-property-value f "SHAPE_AREA"  1 ]
  gis:apply-coverage owf-dataset "SHAPE_AREA" owf-fraction

  ask patches with [not (owf-fraction < 0 or owf-fraction > -1) ] [ set owf-fraction 0 ]


end

; EmodNet provides human activities at https://www.emodnet-humanactivities.eu/download-data.php.
; After providing your country and sector, the wind farm polygon areas are freely available.
to show-windfarms

  ;foreach gis:feature-list-of owf-dataset [
  ;  this-owf-vector-feature -> gis:set-property-value this-owf-vector-feature "POWER_MW" read-from-string gis:property-value this-owf-vector-feature "POWER_MW"
  ;]

  gis:apply-coverage owf-dataset "POWER_MW" owf-fraction
  ask patches with [not (owf-fraction < 0 or owf-fraction > -1) ] [ set owf-fraction 0 ]

  gis:set-drawing-color red
  gis:draw owf-dataset 1

end

to load-plaice-box
  let _dataset  gis:load-dataset "../data/plaicebox/DB_PlaiceBox_WGS84_vTIwi_Jan2001_G.shp"
  ask patches gis:intersecting _dataset [ set plaice-box? true ]

  gis:set-drawing-color blue - 3
  gis:draw _dataset 1
end


to draw-dataset [_dataset-name _color]
  gis:set-drawing-color _color
  gis:draw load-dataset _dataset-name 1
end

; This routines displays additional data not generated by the model but
; sourced from third-party data
to show-dataset [_dataset-name]

  if any? legends [ask legends [die]]
  if any? legend-entries [ask legend-entries [die]]
  let n view-legend-n
  let _qt nobody
  let _values nobody
  let _patches nobody
  let _colors nobody
  let _min 0

  ask patches with [ accessible? ][set pcolor grey]

  if _dataset-name = "EMODnet TBB effort" [
    let _dataset gis:load-dataset "../data/emodnet/fishingbeamtrawlsPolygon.shp"
    gis:apply-coverage  _dataset "MW_FSHN" temporary
    set _qt (list 1 10 50 100 250 400 600  800 1000)
    set n (length _qt) - 1
    set _colors palette:scheme-colors "Sequential" "Oranges" n
  ]

  if _dataset-name = "Effort" [
    ask patches [set temporary 365.25 / ticks *  fishing-effort-hours / area]
    set _qt (list 1 10 50 100 250 400 600  800 1000)
    set n (length _qt) - 1
    set _colors palette:scheme-colors "Sequential" "Oranges" n
  ]

  if _dataset-name = "Bathymetry" [
    ask patches [set temporary depth]
    set _qt (list 0 1 2 5 10 20 30 40  80)
    set n (length _qt) - 1
    set _colors palette:scheme-colors "Sequential" "Blues" n
  ]

  if _dataset-name = "Depth" [

    calculate-tidal-depth
    set _qt (list 0 1 2 5 10 20 30 40  80)
    set n (length _qt) - 1
    set _colors palette:scheme-colors "Sequential" "Blues" n
  ]


  ask patches with [not (temporary < _min or temporary > _min - 1) ] [ set temporary 0 ]
  set _patches [self] of patches with [temporary >= _min]

  set _values (map [ p -> [temporary] of p ] _patches )

  if _qt = nobody [ set _qt quantile-thresholds _values n ]

  set _values quantile-scale-new _qt _values

  foreach  (range length _patches) [ i ->
    ask item i _patches [
      set pcolor palette:scale-gradient _colors (item i _values) 0 1
    ]
  ]
  draw-legend _colors (n-values (n + 1) [ i -> formatted-number (item i _qt) 5])

end

to-report load-dataset [_dataset-name]

  if _dataset-name = "Natura2000" [ report gis:load-dataset "../data/natura2000/northsea/MPA_NorthSea_Shapes.shp"]
  if _dataset-name = "NP" [ report gis:load-dataset "../data/nlwkn/NLP/Nationalparke_DTK25.shp"]
  if _dataset-name = "ICES" [ report gis:load-dataset "../data/ices/ICES_Statistical_Rectangles_Eco.shp"]
  if _dataset-name = "EEZ" [ report gis:load-dataset "../data/eez/eez.shp"]
  if _dataset-name = "Plaicebox" [ report gis:load-dataset "../data/plaicebox/DB_PlaiceBox_WGS84_vTIwi_Jan2001_G.shp"]
  if _dataset-name = "OWF" [ report gis:load-dataset "../data/emodnet/EMODnet_HA_Energy_WindFarms_pg_20230605.shp"]
  if _dataset-name = "SNS" [ report gis:load-dataset "../data/coastline/sns_waterbody.shp"]

  print (sentence "Invalid dataset name" _dataset-name ".  Valid are 'Natura2000', 'NP', 'ICES', 'Plaicebox', 'EEZ', 'OWF', 'SNS', ")
  report nobody
end

to-report __test-load-dataset
  if load-dataset "Natura2000" = nobody [report false]
  if load-dataset "NP" = nobody [report false]
  if load-dataset "ICES" = nobody [report false]
  if load-dataset "EEZ" = nobody [report false]
  if load-dataset "Plaicebox" = nobody [report false]
  if load-dataset "OWF" = nobody [report false]
  if load-dataset "SNS" = nobody [report false]
  report true
end

to-report  __test-draw-dataset

  foreach (list "Natura2000" "NP" "ICES" "EEZ" "Plaicebox" "OWF" "SNS") [ i ->
    draw-dataset i 5 + 10 * (random 14)
  ]
  report true
end

; The `import-wms-drawing` primitive asks a server (in this case one run by
; terrestris.de, a german GIS company that offers a WMS for the public)
; for the section of the map within the current world envelope
; and then draws it to the screen.
;
; In addition to the url of the WMS server, you must also supply the EPSG code
; for the projection you want to use and the name of the layer you want to grab
; from that server as well as a transparency parameter from 0 to 255.
; If you do not know what EPSG code to use, 4326, the code for WGS84, should
; provide good-enough results.
to draw-background [X]

  if member? X  (list "OSM" "SAR" "CHL") [ clear-drawing]

  carefully [
    if X = "OSM" [gis:import-wms-drawing "https://ows.terrestris.de/osm/service?" "EPSG:4326" "OSM-WMS" 200]
    if X = "SAR" [gis:import-wms-drawing "https://hub.hereon.de/server/services/NOAH_geoDB/TI_SARnested/MapServer/WMSServer?" "EPSG:4326" "0" 100]
    if X = "CHL" [gis:import-wms-drawing "https://hub.hereon.de/server/services/MOSSCO/MOSSCO_chlorophyll/MapServer/WmsServer?" "EPSG:4326" "0" 200]
  ][
    show word "Could not load " X
  ]

end

to export-patches
  gis:store-dataset gis:patch-dataset fishing-effort-hours (word "results/fishing-effort-hours_" (formatted-int ticks 4) "_" datetime-short)
  gis:store-dataset gis:patch-dataset depth "results/depth"
  gis:store-dataset gis:patch-dataset owf-fraction "results/owf-fraction"
  gis:store-dataset gis:patch-dataset accessible? "results/accessible"
  gis:store-dataset gis:patch-dataset plaice-box? "results/plaice-box"
end


to calculate-distance-to-coast
  let _water-patches patches with [depth >= 0]
  let _land-patches patches with [depth < 0]
  ask _water-patches  [
    let _coast-patch min-one-of _land-patches [distance myself]
    set distance-to-coast gis-envelope-distance (patch-set self _coast-patch)
  ]
  ask _land-patches  [
    let _coast-patch min-one-of _water-patches [distance myself]
    set distance-to-coast gis-envelope-distance (patch-set self _coast-patch)
  ]
end

to calculate-distance-to-port
  ask patches  [
    let _port min-one-of ports [distance myself]
    set distance-to-coast gis-envelope-distance (patch-set self [patch-here] of _port)
  ]
end

to calculate-tidal-depth
  let _patches patches with [accessible? or depth > 10]

  ; identify patches influenced by tides
  let _tidal-patches _patches with [depth <= 4 and distance-to-coast < 5 ]

  ask _patches [set temporary depth]

  ; Assume a 12:25 h lunar tide with 2 m amplitude in all Wadden patches
  ask _tidal-patches [
    set temporary depth + 2 * sin ( 2 * pi * (time:get "hours" date + 24 * time:get "dayofyear" date + 365.25 * time:get "year" date) / 12.42)
  ]
end
